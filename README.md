# Теоретическая часть
A* - алгоритм поиска пути на графе, который находит маршрут с наименьшей стоимостью от начальной вершины к конечной.

A* является информированным алгоритмом поиска, порядок обхода вершин определяется эвристической функцией, оценивающей расстояние от заданной вершины до конечной.

Эвристическая функция должна иметь какие-либо данные о графе для оценки состояния. В этой реализации предполагается, что вершины графа являются точками на плоскости. В зависимости от структуры графа, для оценки расстояния есть функции, вычисляющие Евклидово, Манхэттенское расстояние и расстояние Чебышёва.

Так как A* по сути является расширением алгоритма Дейкстры, то использование эвристической функции, всегда возвращающей 0 (`Heuristics.NullDistance`) сводит этот алгоритм к алгоритму Дейкстры.

# Инструкция по использованию
Для запуска:
создать входную xml'ку в соответвие с форматом
Выбрать предпочитаемую эвристику (или "я девушка, я не хочу ничего решать" и оставить Евклида)) 
Ввести `astar input.xml output.txt [Euclid|Chebyshev|Manhattan|Null]`

# Описание формата входных и выходных данных
Во входных данных должны быть рёбра, с указанием их весов, вершины, с указанием координат, которые будут использоваться эвристикой, а также указание начальной и конечной вершины. Много всего. И, как программист на java, я считаю, что в моём дз недостатаёт XML. Поэтому граф рисуется в https://www.draw.io/ и экспортируется как XML (Plain). Для вершин используются прямоугольники (rectangle), рёбра получаются соединением прямоугольников через соответствующие маркеры. Начальная и конечная вершина отмечаются добавлением (даблкликом) текста "start" и "end" к прямоугольнику. Так же добавляются веса к рёбрам. Граф считается неориентированным, так как добавлять 2й конец ко всем стрелочкам леень. Хотя с орграфом всё работает, его просто нельзя загрузить из файла.

# Выходные данные
Выходной файл содержит строки из пар координат (X Y) вершин пути от начальной вершины к конечной.


# Оценка сложности основных алгоритмов программы
Так как при обращении к графу алгоритм использует только обход соседей данной вершины, то граф хранится в виде списка рёбер, исходящих из каждой вершины.

Для списка просмотренных вершин `closed` требуются операции `.Add` и `.Contains`. Для этого лучше всего подходит `HashSet<>`, реализованный на основе хеш-таблицы и выполняющий обе операции за `O(1)`.

Для списка вершин, которые будут просмотрены `queue` требуются операции получения элемента с наименьшей оценкой и добавления элемента. Это очередь с приоритетом. Существуют различные способы реализовать очередь с приоритетом, которые имеют сложность `O(1)` для одной операции и `O(n)` для другой (массив, сортированный список) или `O(log n)` для обеих операций (например, на основе кучи). Вариант с `O(log n)` более эффективен, здесь реализован вариант на основе `SortedDictionary` (внутри - двоичное дерево поиска), элементы которого - список вершин с данным приоритетом, как требующий наименьшего велосипедостроения.

Общая оценка сложности алгоритма зависит от использованных структур данных и подхода к оценке. Для пути заданной длинны сложность оценивается исходя из его длины и коэффициента разветвления. 

Для заданного графа в худшем случае сложность определяется операциями над очередью с приоритетом: получаем `O(|V|)` вставок в очередь и такая же для получений. Таким образом получаем сложность `O(|E|*log(|E|))`.

Требуемая память состоит из памяти на `HashSet<> closed` и `PriorityQueue queue`, которые в худшем случае содержат до |V| элементов и, соответственно, используют `O(|V|)` памяти каждый. Следовательно, алгоритм использует `O(|V|)` дополнительной памяти в худшем случае.

